TITLE:: NPModules
summary:: registry of small reusable module functions for NodeProxy
categories:: Live Coding>ProxySpace
related:: Classes/NodeProxy, Classes/Ndef, Classes/ProxySpace, Classes/AbstractPlayControl, Classes/SynthDefControl

DESCRIPTION::
Provides a light-weight way to define and reuse small signal / filter / utility modules to populate a link::Classes/NodeProxy::.

Instead of writing full functions each time, you can reference a named module.

code::
// simplest: refer to an existing module by name (Symbol)
Ndef(\tone, \module -> \sine);   // looks up \sine in NPModules for that proxyspace

// with parameters: pass a Dictionary containing at least \name and optional params
Ndef(\tone2, \module -> (name: \sine, freq: 220));
::

CLASSMETHODS::

METHOD:: new
argument:: proxyspace 
The code::ProxySpace:: this instance operates on. Defaults to the Ndef proxyspace for the default server.
If not the default Ndef proxyspace, the instance must be named and thus included in code::ProxySpace.all::.
Returns:: An code::NPModules:: instance.

METHOD:: parentDict
The prototype dictionary of built-in modules.
Can be adapted and extended for global changes.
Changing elements here is propagated to existing code::NPModules:: instances, however, existing instances in code::NodeProxy:: instances are not updated automatically.


METHOD:: all
A dictionary of all code::NPModules:: instances.

METHOD:: registerToAbstractPlayControl
announces the code::\module -> :: role for code::NodeProxy:: instances. See link::Reference/NodeProxy_roles:: .

METHOD:: krFunc
helper function to create kr control functions with index suffix to avoid name clashes when multiple instances of the same module are used e.g. code::\freq -> \freq0, \freq1, ...::

code::
(
NPModules()[\sines] = {|dict, idx|
	var amp = NPModules.krFunc(\amp, \amp.asSpec, dict, idx);
	var lfreq = NPModules.krFunc(\lfreq, [10, 40, \exp], dict, idx);	
	var mfreq = dict[\mfreq] ? 440; // fixed value that can be overridden by dict
	var hfreq = dict[\hfreq] ?? {{\hfreq.kr(880)}}; // if not overridden, use a NamedControl that has a fixed name, no matter how many instances of this module (and others with a hfreq NamedControl) are used.
	{
        amp * SinOsc.ar(mfreq + (SinOsc.kr(lfreq) * hfreq))
	}
};
)

Ndef(\a)[0] = \module -> \sines; // controls: lfreq0, 440, hfreq (shared with others)
Ndef(\a)[1] = \module -> \sines; // controls: lfreq1, 440, hfreq (shared with others)
Ndef(\a)[10] = \module -> \sines; // controls: lfreq10, 440, hfreq (shared with others)
Ndef(\a)[13] = \module -> \sines; // controls: lfreq13, 440, hfreq (shared with others)

Ndef(\a).edit
::

argument:: name
the base name (Symbol).
argument:: spec
the spec to use
argument:: dict
the dictionary passed to the module function.
argument:: idx
the index of the NodeProxy instance.
argument:: lag
lag time. defaults to 0
RETURNS:: A function that returns a link::Classes/NamedControl:: with the appropriate name and spec.




PRIVATE:: initClass

INSTANCEMETHODS::

METHOD:: moduleDict
dictionary of modules.

METHOD:: moduleKeys
Returns:: A code::Set:: of all module names (code::Symbol::) available.


METHOD:: proxyspace
The proxyspace dictionary this instance operates on.


METHOD:: at
argument:: key 
Symbol name of module.
Returns:: The module function (or role-returning function) or nil if not found.

METHOD:: put
argument:: key 
Symbol name to bind.
argument:: value 
Function receiving a dict and returning either a UGen function or a role mapping.
argument:: updateNodes 
Boolean (default false).
Returns:: The value inserted.

EXAMPLES::

code::
// Basic sine with default frequency
Ndef(\a, \module -> \sine).play;

// sine with fixed frequency
Ndef(\a, \module -> (name: \sine, freq: 330)).play;

// sine with frequency control
Ndef(\a, \module -> (name: \sine, freq: {\freq.kr(100)})).play;
::

Distort a custom sound (in slot code::0::):

code::
Ndef(\a, {PMOsc.ar}); // simple sine
::


Write your own modules by adding it to the registry for the relevant ProxySpace:

code::
// Add custom module
n = NPModules(); // nil means the default Ndef space

n.put(\simpleSound, { |dict| 
    var f = dict[\freq] ? 200; 
    { LFTri.ar(f) } // returns a UGen function
});
::

Then use it in a proxy:

code::
Ndef(\c, \module -> (name: \simpleSound, freq: 150));.play;
::

Change the sound by redefining the module:

code::
n.put(\simpleSound, { |dict| 
    var f = dict[\freq] ? 200; 
    { LPF.ar(LFSaw.ar(f), f * 2) } // new definition
}, updateNodes: true); // rebuild any proxies using this module
::

